#### 문제

``` 
문자열이 주어지면 숫자, 문자, 기호가 몇개인지 출력하는 함수를 만들어봐
```

```
def check(input_str):
  char_count = 0
  digit_count = 0
  symbol_count = 0

  for char in input_str:
    if char.isalpha():
      char_count += 1
    elif char.isdigit():
      digit_count += 1
    else:
      symbol_count += 1
  
  return (char_count, digit_count, symbol_count)

input_str = "dsgs@$@#_snow"
char_count, digit_count, symbol_count = check(input_str)
print(f"char : {char_count}, digit : {digit_count}, symbol : {symbol_count}")

``` 

### 순서가 없는 데이터 구조

```
셋 & 딕셔너리
```

```
데이터 구조란?
여러 데이터를 효과적으로 사용, 관리하기 위한 구조.
파이썬에서는 대표적으로 list, tuple, dict, set
```
# Set
```
Set이란 중복되는 요소가 없이 순서에 상관없는 데이터들을 묶음.
순서가 없기 때문에 인덱스를 이용한 접근 불가능.
집합 연산이 가능.
담고 있는 요소를 삽입 변경, 삭제 가능 -> 가변 자료형.
```
### Set의 메서드
```
s.copy() : 셋의 얕은 복사본을 반환.
s.add(x) : 항목 x가 셋 s에 없다면 추가
s.pop() : 셋 s에서 랜덤하게 항목을 반환하고 해당 항목을 제거 set이 비어 있을 경우  keyError
s.remove(s) : 항목 x를 셋 s에서 삭제.
```

### Set의 형태 및 사용
```
a = {'사과' , '바나나' , '수박'}
print(a) -> 출려할 떄 마다 순서가 바뀜
a.add('딸기') -> set에 딸기 추가
a.update(['딸기' , '바나나' , '참외']) -> 여러개를 한번에 추가 하지만 바나나는 이미 있기 때문에 추가되지 않는다.
a.remove('바나나') -> 바나나 삭제
.pop() -> 제거 뿐 아니라 제거한 것을 반환까지 한다.
x =  a.pop() -> a에서 제거 뿐 아니라 제거한 값을 x에 반환하여 준다.
```

# 딕셔너리
```
 키-값 쌍으로 이뤄진 자료형.
 key는 변경 불가능한 데이터만 활용
 ```

 ### 딕셔너리 메서드
 ```
 d.keys() , d.values(), d.get(k), d.items()
 ```

 ```
 조회
 .get(key[,default])
 .pop(key[,default])
 ```

 ### 얕은 복사와 깊은 복사
 ```
 자료형과 메모리
 데이터 10을 컴퓨터가 기억하는 과정
 1. 10을 저장할 공간을 메모리에 만들고
 2. 저장할 공간에 대한 주소를 할당받는다.
 3. 할당 받은 주소를 기억했다가
 4. 10이라는 데이터를 해당 주소로 찾아가서 저장한다.
 5. 이후에 10이 필요해지면 해당 주소로 가서 읽어온다.

? 하나의 기억에, 하나의 주소가 필요 -> 100개 저장하려면 주소 100개가 필요함.
연속적인 공간에 데이터가 저장되도록 함.
-> 맨 처음 기억의 주소만 가지고 있으면 뒤는 찾아갈 수 있음.

얕은 복사 : =을 사용하여 같은 데이터를 보고 있는 상태

깊은 복사 : 메모리의 다른 공간에 복사 이 경우 복사한 데이터를 변경하여도 원본은 변경되지 않는다.
```
### 복사방법 (할당, 얕은 복사, 깊은 복사)

#### 할당
```
original_list = [1, 2, 3]
copy_list = original_list
copy_list[0] = 'hello'
이 경우 original_list도 변경된다.

참조 -> 주소 값과 연관
대입 연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사
```

#### 얕은 복사
```
Slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)

slice 연산자가 얕은 복사인 이유
a = [1, 2, ['a', 'b']]
b = a[:]

a의 경우 a[0]의 주소에는 1 a[1]의 주소에는 2 a[2]의 주소에는 'a'와 'b'의 시작점 주소를 가르키는 값이 있다.

a를 슬라이스 복사한다면 다른 곳에 저장되기는 하지만 'a', 'b'를 가르키는 주소가 복사되어 b에서'a','b'부분을 수정한다면 a도 같이 변경된다.
따라서 얕은 복사이다.
```
#### 깊은복사
```
import copy
a = [1, 2, ['a', 'b']]
b = copy.deepcopy(a)

이렇게 하면 깊은 복사
```